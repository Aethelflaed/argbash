#!/bin/bash

version=2.1.1
# ARG_POSITIONAL_SINGLE([output],[Name of the output template],["-"])
# ARG_OPTIONAL_INCREMENTAL([separate],[s],[Separate the parsing logic (specify two times for complete separation)])
# ARG_OPTIONAL_BOOLEAN([hints],[],[Whether to write hints to the script template])
# ARG_OPTIONAL_REPEATED([pos],[],[Add a single-valued positional argument])
# ARG_OPTIONAL_REPEATED([opt],[],[Add an single-valued optional argument])
# ARG_OPTIONAL_REPEATED([opt-bool],[],[Add an optional boolean argument])
# ARG_OPTIONAL_REPEATED([wrap],[],[What script(s) to wrap])
# ARG_VERSION([echo "argbash-init v$version"])
# ARG_HELP([Make a template for scripts.])

# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.1.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, know your rights: https://github.com/matejak/argbash

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_arg_output="-"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_separate=0
_arg_hints=off
_arg_pos=()
_arg_opt=()
_arg_opt_bool=()
_arg_wrap=()

# THE PRINT HELP FUNCION
print_help ()
{
	echo "Make a template for scripts."
	printf 'Usage: %s [-s|--separate] [--(no-)hints] [--pos <arg>] [--opt <arg>] [--opt-bool <arg>] [--wrap <arg>] [-v|--version] [-h|--help] [<output>]\n' "$0"
	printf "\t<output->: Name of the output template (default: '""-""')\n"
	printf "\t-s,--separate: Separate the parsing logic (specify two times for complete separation)\n"
	printf "\t--hints,--no-hints: Whether to write hints to the script template (%s by default)\n" "off"
	printf "\t--pos: Add a single-valued positional argument (empty by default)\n" "()"
	printf "\t--opt: Add an single-valued optional argument (empty by default)\n" "()"
	printf "\t--opt-bool: Add an optional boolean argument (empty by default)\n" "()"
	printf "\t--wrap: What script(s) to wrap (empty by default)\n" "()"
	printf "\t-v,--version: Prints version\n"
	printf "\t-h,--help: Prints help\n"
}

# THE PARSING ITSELF
while test $# -gt 0
do
	_key="$1"
	case "$_key" in
		-s|--separate)
			_arg_separate=$((_arg_separate + 1))
			;;
		--no-hints|--hints)
			_arg_hints="on"
			test "${1:0:5}" = "--no-" && _arg_hints="off"
			;;
		--pos|--pos=*)
			_val="${_key##--pos=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_pos+=("$_val")
			;;
		--opt|--opt=*)
			_val="${_key##--opt=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_opt+=("$_val")
			;;
		--opt-bool|--opt-bool=*)
			_val="${_key##--opt-bool=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_opt_bool+=("$_val")
			;;
		--wrap|--wrap=*)
			_val="${_key##--wrap=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_wrap+=("$_val")
			;;
		-v|--version)
			echo "argbash-init v$version"
			exit 0
			;;
		-h|--help)
			print_help
			exit 0
			;;
		*)
			_positionals+=("$1")
			;;

	esac
	shift
done

_positional_names=('_arg_output' )
test ${#_positionals[@]} -lt 0 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 0 and 1, but got only ${#_positionals[@]}." 1
test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
	eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#


_variables=()


do_hints_pos()
{
	_help="[<$1's help message goes here>]"
	test "$_arg_hints" = on && _default="[<$1's default goes here (optional)>]"
}


do_hits_opt()
{
	do_hints_pos "$1"
	if test "$_arg_hints" = on
	then
		_short_opt="[<short option character goes here (optional)>]"
	fi
}


do_opt()
{
	do_hits_opt "$1"
	echo "# ARG_OPTIONAL_SINGLE([$1], $_short_opt, $_help)"
	_variables+=('echo "Value of --'$1': $_arg_'$1'"')
}


do_opt_bool()
{
	do_hits_opt "$1"
	echo "# ARG_OPTIONAL_BOOLEAN([$1], $_short_opt, $_help)"
	_variables+=('echo "'$1' is $_arg_'$1'"')
}


do_pos()
{
	do_hints_pos "$1"
	echo "# ARG_POSITIONAL_SINGLE([$1], $_help, $_default)"
	_variables+=('echo "Value of '$1': $_arg_'$1'"')
}


do_header()
{
	echo "#!/bin/bash"
	echo
	# We if separate == 2, we don't want to pass this to argbash at all
	test "$_arg_separate" = 2 && test "$1" = "script" && echo "# Created by argbash-init v$version" && return
	echo "# m4_ignore("
	if test "$1" = "lib"
	then
		echo "echo \"This is just a parsing library template, not the library - pass the parent script '$outfname' to 'argbash' to fix this.\" >&2"
	else
		echo "echo \"This is just a script template, not the script (yet) - pass it to 'argbash' to fix this.\" >&2"
	fi
	echo "exit 11  #)Created by argbash-init v$version"
}


do_args()
{
	test "$_arg_hints" = on && echo "# Rearrange the order of options below according to what you would like to see in the help message."
	for name in "${_arg_opt[@]}"
	do do_opt "$name"; done
	for name in "${_arg_opt_bool[@]}"
	do do_opt_bool "$name"; done
	for name in "${_arg_pos[@]}"
	do do_pos "$name"; done
}


do_args_footer()
{
	echo "# ARG_HELP([<The general help message of my script>])"
	echo "# ARGBASH_GO"
}


do_script_assisted()
{
	do_header script

	echo "# DEFINE_SCRIPT_DIR()"
	echo "# INCLUDE_PARSING_CODE([$(basename "${parse_fname_stem}.sh")])"
	echo "# ARGBASH_GO"

	do_body_protected
}


do_script_bare()
{
	do_header script
	parse_fname=${parse_fname_stem}.sh

	echo 'script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"'
	echo '. "${script_dir}/'"$(basename "$parse_fname")\" || { echo \"Couldn't find '$(basename "$parse_fname")' parsing library in the '"'$script_dir'"' directory\"; exit 1; }"
	echo

	do_body
}


do_body()
{
	for stat in "${_variables[@]}"
	do
		echo "$stat"
	done
}


do_body_protected()
{
	echo
	echo "# [ <-- needed because of Argbash"
	echo
	do_body
	echo
	echo "# ] <-- needed because of Argbash"
}


do_stuff()
{
	do_header "$1"
	do_args
	do_args_footer

	test "$_arg_separate" = 0 && do_body_protected
}

outfname="$_arg_output"
test "$outfname" = "-" -a "$_arg_separate" -gt 0 && die "If you want to separate parsing and script body, you have to specify the outname, stdout doesn't work."

if test "$outfname" = '-'
then
	do_stuff 'script'
else
	test "$_arg_separate" = 0 && do_stuff 'script' > "$outfname" || parse_fname_stem="$(echo "${outfname}" | sed -e 's/\.\(sh\|m4\)$//')-parsing"
	# IMPORTANT NOTION:
	# do_stuff has to be called FIRST, because it sets the _variables array content as its side-effect
	test "$_arg_separate" = 1 && {
		do_stuff 'lib' > "${parse_fname_stem}.m4"
		do_script_assisted > "$outfname"
	}
	test "$_arg_separate" = 2 && {
		do_stuff 'lib'  > "${parse_fname_stem}.m4"
		do_script_bare > "$outfname"
	}
	chmod a+x "$outfname"
fi

#
# ] <-- needed because of Argbash
