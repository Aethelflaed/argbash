#!/bin/bash

version=2.1.1
# ARG_POSITIONAL_INF([input],[The input file to transform],[1])
# ARG_OPTIONAL_SINGLE([output],[o],[Name of the output file (pass '-' for stdout and empty string for the same as input file)],[""])
# ARG_VERSION([echo "argbash-1to2 v$version"])
# ARG_HELP([Convert a template for argbash>=1,<2 to argbash>=2,<3])

# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.1.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, know your rights: https://github.com/matejak/argbash

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_arg_input=('' )
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output=""

# THE PRINT HELP FUNCION
print_help ()
{
	echo "Convert a template for argbash>=1<2 to argbash>=2<3"
	printf 'Usage: %s [-o|--output <arg>] [-v|--version] [-h|--help] <input-1> [<input-2>] ... [<input-n>] ...\n' "$0"
	printf "\t<input>: The input file to transform('' )\n"
	printf "\t-o,--output: Name of the output file (pass '-' for stdout and empty string for the same as input file) (default: '%s')\n" ""
	printf "\t-v,--version: Prints version\n"
	printf "\t-h,--help: Prints help\n"
}

# THE PARSING ITSELF
while test $# -gt 0
do
	_key="$1"
	case "$_key" in
		-o|--output|--output=*)
			_val="${_key##--output=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_output="$_val"
			;;
		-v|--version)
			echo "argbash-1to2 v$version"
			exit 0
			;;
		-h|--help)
			print_help
			exit 0
			;;
		*)
			_positionals+=("$1")
			;;
	esac
	shift
done

_positional_names=('_arg_input' )
test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1, but got only ${#_positionals[@]}." 1
_OUR_ARGS=$((${#_positionals[@]} - ${#_positional_names[@]}))
for (( ii = 0; ii < _OUR_ARGS; ii++))
do
	_positional_names+=("_arg_input[(($ii + 1))]")
done

for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
	eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#

do_stuff ()
{
	# SCRIPT_DIR is likely also a default, but maybe not - it may have been set explicitly
	grep -q '\${\?SCRIPT_DIR' -- "$infname" && echo "You probably use a variable 'SCRIPT_DIR' in your script. It may be that you should rename it to 'script_dir', but this is not certain :-(" >&2
	# We match $_ARG_FOO as well as ${ARG_FOO...
	# and _ARGS_FOO
	sed 's/\(\${\?_ARGS\?_\w\+\)/\L\1\l/g' "$infname"
}

outfname="$_arg_output"
test "${#infname[@]}" -gt 1 && test -n "$outfname" && die "You have specified more than one (${#infname[@]}) input filenames, so you probably want to modify the corresponding files in-place. In order to do so, you can't specify an output filename, even '-' does make no sense (currently: '$outfname')"

for infname in "${_arg_input[@]}"
do
	test -f "$infname" || { echo "The input parameter has to be a file (got: '$infname')" >&2; exit 1; }

	test -n "$_arg_output" || outfname="$infname"
	if test "$outfname" = '-'
	then
		do_stuff
	else
		# vvv This should catch most of the cases when we want to overwrite the source file
		# vvv and we don't want to leave a file (not even an empty one) when something goes wrong.
		temp_outfile="temp_$$"
		trap "rm -f $temp_outfile" EXIT
		do_stuff > "$temp_outfile"
		mv "$temp_outfile" "$outfname"
		# So we don't make .m4 scripts executable
		chmod --reference "$infname" "$outfname"
	fi
done

#
# ] <-- needed because of Argbash
