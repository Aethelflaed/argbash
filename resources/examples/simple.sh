#!/bin/bash

# ARG_POSITIONAL_SINGLE([filename])
# ARG_OPTIONAL_SINGLE([unit],[u],[What unit we accept (b for bytes, k for kibibytes, M for mebibytes)],[b])
# ARG_VERSION([echo $0 v0.1])
# ARG_OPTIONAL_BOOLEAN([verbose])
# ARG_HELP([This program tells you size of file that you pass to it in chosen units.])
#
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY ARGBASH v1.3.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, know your rights: https://github.com/matejak/argbash

# THE DEFAULTS INITIALIZATION --- POSITIONALS
# THE DEFAULTS INITIALIZATION --- OPTIONALS
_ARG_UNIT="b"
_ARG_VERBOSE=off

# THE PRINT HELP FUNCION
print_help ()
{
  echo "This program tells you size of file that you pass to it in chosen units."
  printf 'Usage: %s [-u|--unit <arg>] [-v|--version] [--(no-)verbose] [-h|--help] <filename>\n' "$0"
  printf "\t-u,--unit: What unit we accept (b for bytes, k for kibibytes, M for mebibytes) (default: '%s')\n" "${_ARG_UNIT}"
  printf "\t-v,--version: Prints version\n"
  printf "\t-h,--help: Prints help\n"
}

# THE PARSING ITSELF
while test $# -gt 0
do
  _key="$1"
  case "$_key" in
    -u|--unit)
      test $# -lt 2 && { echo "Missing value for the optional argument '$_key'." >&2; exit 1; }
      _ARG_UNIT="$2"

      shift
      ;;
    -v|--version)
      echo $0 v0.1
      exit 0
      ;;
    --no-verbose|--verbose)
      _ARG_VERBOSE="on"

      test "${1:0:5}" = "--no-" && _ARG_VERBOSE="off"
      ;;
    -h|--help)
      print_help
      exit 0
      ;;
    *)
      _positionals+=("$1")
      ;;
  esac
  shift
done

_positional_names=('_ARG_FILENAME' )
test ${#_positionals[@]} -lt 1 && { ( echo "FATAL ERROR: Not enough positional arguments --- we require exactly 1, but got only ${#_positionals[@]}."; print_help ) >&2; exit 1; }
test ${#_positionals[@]} -gt 1 && { ( echo "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')."; print_help ) >&2; exit 1; }
for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
  eval "${_positional_names[$ii]}=\"${_positionals[$ii]}\"" || { echo "Error during argument parsing, possibly an Argbash bug." >&2; exit 1; }
done

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# ARG_HELP  <-- Unlike one above, his one does not disappear, it is behind the escape bracket.

# Now we take the parsed data and assign them no nice-looking variable names,
# sometimes after a basic validation
verbose=$_ARG_VERBOSE
unit=$_ARG_UNIT

test -f $_ARG_FILENAME || { echo "Filename $_ARG_FILENAME doesn't seem to belong to a file"; exit 1; }
filename="$_ARG_FILENAME"

if [ $verbose = on ]
then
	_b="bytes (B)"
	_kb="kibibytes (kiB)"
	_mb="mebibytes (MiB)"
else
	_b="B"
	_kb="kiB"
	_mb="MiB"
fi

size_bytes=$(wc -c "$filename" | cut -f 1 -d ' ')

test "$unit" = b && echo $size_bytes $_b && exit 0

size_kilobytes=$(expr $size_bytes / 1024)
test "$unit" = k && echo $size_kilobytes $_kb && exit 0

size_megabytes=$(expr $size_kilobytes / 1024)
test "$unit" = M && echo $size_megabytes $_mb && exit 0

test "$verbose" = on && echo "The unit '$unit' is not supported!"
exit 1

# ] <-- needed because of Argbash
