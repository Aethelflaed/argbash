#!/bin/bash

# Created by argbash-init v2.4.1a
# ARG_OPTIONAL_SINGLE([option],[o],[A option with short and long flags and default],[boo])
# ARG_OPTIONAL_BOOLEAN([print],[],[A boolean option with long flag (and implicit default: off)])
# ARG_POSITIONAL_SINGLE([positional-arg],[Positional arg description],[])
# ARG_HELP([This is a minimal demo of Argbash potential])
# ARG_VERSION([echo $0 v0.1])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.4.1a one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# When called, the process ends.
# Args:
# _INDENT_()$1: The exit message (print to stderr)
# _INDENT_()$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to )
# Example:
# _INDENT_()test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

# Function that evaluates whether a value passed to it
# begins by a character that is a short option of an argument
# the script knows about
begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='ohv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
# The positional args array has to be reset before the parsing, because it may already be defined
# - for example if this script is sourced by an argbash-powered script.
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_option="boo"
_arg_print=off

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help ()
{
  printf "%s\n" "This is a minimal demo of Argbash potential"
  printf 'Usage: %s [-o|--option <arg>] [--(no-)print] [-h|--help] [-v|--version] <positional-arg>\n' "$0"
  printf "\t%s\n" "<positional-arg>: Positional arg description"
  printf "\t%s\n" "-o,--option: A option with short and long flags and default (default: '"boo"')"
  printf "\t%s\n" "--print,--no-print: A boolean option with long flag (and implicit default: off) (off by default)"
  printf "\t%s\n" "-h,--help: Prints help"
  printf "\t%s\n" "-v,--version: Prints version"
}

# The parsing of the command-line
parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      # We support whitespace as a delimiter between option argument and its value.
      # Therefore, we expect the --option or -o value.
      # so we watch for --option and -o.
      # Since we know that we got the long or short option,
      # we just reach out for the next argument to get the value.
      -o|--option)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_option="$2"
        shift
        ;;
      # We support the = as a delimiter between option argument and its value.
      # Therefore, we expect --option=value, so we watch for --option=*
      # For whatever we get, we strip '--option=' using the ${var##--option} notation
      # to get the argument value
      --option=*)
        _arg_option="${_key##--option=}"
        ;;
      # We support getopts-style short arguments clustering,
      # so as -o accepts value, we allow it to be appended to it, so we watch for -o*
      # and we strip the leading -o from the argument string using the ${var##-o} notation.
      -o*)
        _arg_option="${_key##-o}"
        ;;
      # The print argurment doesn't accept a value,
      # we expect the --print, so we watch for it.
      --no-print|--print)
        _arg_print="on"
        test "${1:0:5}" = "--no-" && _arg_print="off"
        ;;
      # See the comment of option --print to see what's going on here
      -h|--help)
        print_help
        exit 0
        ;;
      # We support getopts-style short arguments clustering,
      # so as -h doesn't accepts value, other short options may appended to it, so we watch for -h*.
      # After strip the leading -h from the argument,
      # we have to make sure that the first character coresponds to a short option.
      -h*)
        print_help
        exit 0
        ;;
      # See the comment of option --print to see what's going on here
      -v|--version)
        echo $0 v0.1
        exit 0
        ;;
      # See the comment of option -h to see what's going on here
      -v*)
        echo $0 v0.1
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


# Check that we receive expected amount positional arguments.
# Return 0 if everything is OK, 1 if we have too little arguments
# and 2 if we have too much arguments
handle_passed_args_count ()
{
  _required_args_string="'positional-arg'"
  test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
  test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

# Take arguments that we have received, and save them in variables of given names.
# The 'eval' command is needed as the name of target variable is saved into another variable.
assign_positional_args ()
{
  # We have an array of variables to which we want to save positional args values.
  # This array is able to hold array elements as targets.
  _positional_names=('_arg_positional_arg' )

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


if [ "$_arg_print" = on ]
then
  echo "Positional arg value: '$_arg_positional_arg'"
  echo "Optional arg '--option' value: '$_arg_option'"
else
  echo "Not telling anything, print not requested"
fi

# ] <-- needed because of Argbash
